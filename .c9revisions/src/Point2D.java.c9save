{"ts":1360468540478,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":["bjarnibenedikts@gmail.com"],"silentsave":true,"ts":1360468560101,"patch":[[{"diffs":[[1,"Point2D.java\n\n\nBelow is the syntax highlighted version of Point2D.java from § Algorithms.\n\n\n/*************************************************************************\n *  Compilation:  javac Point2D.java\n *\n *  Immutable point data type for points in the plane.\n *\n *************************************************************************/\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Point2D implements Comparable<Point2D> {\n    public static final Comparator<Point2D> X_ORDER = new XOrder();\n    public static final Comparator<Point2D> Y_ORDER = new YOrder();\n    public static final Comparator<Point2D> R_ORDER = new ROrder();\n\n    public final Comparator<Point2D> POLAR_ORDER = new PolarOrder();\n    public final Comparator<Point2D> ATAN2_ORDER = new Atan2Order();\n    public final Comparator<Point2D> DISTANCE_TO_ORDER = new DistanceToOrder();\n\n    private final double x;    // x coordinate\n    private final double y;    // y coordinate\n\n    // create a new point (x, y)\n    public Point2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    // return the x-coorindate of this point\n    public double x() { return x; }\n\n    // return the y-coorindate of this point\n    public double y() { return y; }\n\n    // return the radius of this point in polar coordinates\n    public double r() { return Math.sqrt(x*x + y*y); }\n\n    // return the angle of this point in polar coordinates\n    // (between -pi/2 and pi/2)\n    public double theta() { return Math.atan2(y, x); }\n\n    // return the polar angle between this point and that point (between -pi and pi);\n    // (0 if two points are equal)\n    private double angleTo(Point2D that) {\n        double dx = that.x - this.x;\n        double dy = that.y - this.y;\n        return Math.atan2(dy, dx);\n    }\n\n    // is a->b->c a counter-clockwise turn?\n    // -1 if clockwise, +1 if counter-clockwise, 0 if collinear\n    public static int ccw(Point2D a, Point2D b, Point2D c) {\n        double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);\n        if      (area2 < 0) return -1;\n        else if (area2 > 0) return +1;\n        else                return  0;\n    }\n\n    // twice signed area of a-b-c\n    public static double area2(Point2D a, Point2D b, Point2D c) {\n        return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);\n    }\n\n    // return Euclidean distance between this point and that point\n    public double distanceTo(Point2D that) {\n        double dx = this.x - that.x;\n        double dy = this.y - that.y;\n        return Math.sqrt(dx*dx + dy*dy);\n    }\n\n    // return square of Euclidean distance between this point and that point\n    public double distanceSquaredTo(Point2D that) {\n        double dx = this.x - that.x;\n        double dy = this.y - that.y;\n        return dx*dx + dy*dy;\n    }\n\n    // compare by y-coordinate, breaking ties by x-coordinate\n    public int compareTo(Point2D that) {\n        if (this.y < that.y) return -1;\n        if (this.y > that.y) return +1;\n        if (this.x < that.x) return -1;\n        if (this.x > that.x) return +1;\n        return 0;\n    }\n\n    // compare points according to their x-coordinate\n    private static class XOrder implements Comparator<Point2D> {\n        public int compare(Point2D p, Point2D q) {\n            if (p.x < q.x) return -1;\n            if (p.x > q.x) return +1;\n            return 0;\n        }\n    }\n\n    // compare points according to their y-coordinate\n    private static class YOrder implements Comparator<Point2D> {\n        public int compare(Point2D p, Point2D q) {\n            if (p.y < q.y) return -1;\n            if (p.y > q.y) return +1;\n            return 0;\n        }\n    }\n\n    // compare points according to their polar radius\n    private static class ROrder implements Comparator<Point2D> {\n        public int compare(Point2D p, Point2D q) {\n            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);\n            if (delta < 0) return -1;\n            if (delta > 0) return +1;\n            return 0;\n        }\n    }\n \n    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point\n    private class Atan2Order implements Comparator<Point2D> {\n        public int compare(Point2D q1, Point2D q2) {\n            double angle1 = angleTo(q1);\n            double angle2 = angleTo(q2);\n            if      (angle1 < angle2) return -1;\n            else if (angle1 > angle2) return +1;\n            else                      return  0;\n        }\n    }\n\n    // compare other points relative to polar angle (between 0 and 2pi) they make with this Point\n    private class PolarOrder implements Comparator<Point2D> {\n        public int compare(Point2D q1, Point2D q2) {\n            double dx1 = q1.x - x;\n            double dy1 = q1.y - y;\n            double dx2 = q2.x - x;\n            double dy2 = q2.y - y;\n\n            if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below\n            else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above\n            else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal\n                if      (dx1 >= 0 && dx2 < 0) return -1;\n                else if (dx2 >= 0 && dx1 < 0) return +1;\n                else                          return  0;\n            }\n            else return -ccw(Point2D.this, q1, q2);     // both above or below\n\n            // Note: ccw() recomputes dx1, dy1, dx2, and dy2\n        }\n    }\n\n    // compare points according to their distance to this point\n    private class DistanceToOrder implements Comparator<Point2D> {\n        public int compare(Point2D p, Point2D q) {\n            double dist1 = distanceSquaredTo(p);\n            double dist2 = distanceSquaredTo(q);\n            if      (dist1 < dist2) return -1;\n            else if (dist1 > dist2) return +1;\n            else                    return  0;\n        }\n    }\n\n\n    // does this point equal y?\n    public boolean equals(Object other) {\n        if (other == this) return true;\n        if (other == null) return false;\n        if (other.getClass() != this.getClass()) return false;\n        Point2D that = (Point2D) other;\n        return this.x == that.x && this.y == that.y;\n    }\n\n    // convert to string\n    public String toString() {\n        return \"(\" + x + \", \" + y + \")\";\n    }\n\n    // plot using StdDraw\n    public void draw() {\n        StdDraw.point(x, y);\n    }\n\n    // draw line from this point p to q using StdDraw\n    public void drawTo(Point2D that) {\n        StdDraw.line(this.x, this.y, that.x, that.y);\n    }\n\n\n    public static void main(String[] args) {\n        int x0 = Integer.parseInt(args[0]);\n        int y0 = Integer.parseInt(args[1]);\n        int N = Integer.parseInt(args[2]);\n\n        StdDraw.setCanvasSize(800, 800);\n        StdDraw.setXscale(0, 100);\n        StdDraw.setYscale(0, 100);\n        StdDraw.setPenRadius(.005);\n        Point2D[] points = new Point2D[N];\n        for (int i = 0; i < N; i++) {\n            int x = StdRandom.uniform(100);\n            int y = StdRandom.uniform(100);\n            points[i] = new Point2D(x, y);\n            points[i].draw();\n        }\n\n        // draw p = (x0, x1) in red\n        Point2D p = new Point2D(x0, y0);\n        StdDraw.setPenColor(StdDraw.RED);\n        StdDraw.setPenRadius(.02);\n        p.draw();\n\n\n        // draw line segments from p to each point, one at a time, in polar order\n        StdDraw.setPenRadius();\n        StdDraw.setPenColor(StdDraw.BLUE);\n        Arrays.sort(points, p.POLAR_ORDER);\n        for (int i = 0; i < N; i++) {\n            p.drawTo(points[i]);\n            StdDraw.show(100);\n        }\n    }\n}\n\n\nCopyright © 2002–2010, Robert Sedgewick and Kevin Wayne. \nLast updated: Tue Oct 18 07:05:59 EDT 2011."]],"start1":0,"start2":0,"length1":0,"length2":7691}]],"length":7691,"saved":false}
{"ts":1360468564581,"patch":[[{"diffs":[[0," }\n}"],[-1,"\n\n\nCopyright © 2002–2010, Robert Sedgewick and Kevin Wayne. \nLast updated: Tue Oct 18 07:05:59 EDT 2011."]],"start1":7583,"start2":7583,"length1":108,"length2":4}]],"length":7587,"saved":false}
{"ts":1360468571424,"patch":[[{"diffs":[[0,"   }"],[-1,"\n\n        // draw p = (x0, x1) in red\n        Point2D p = new Point2D(x0, y0);\n        StdDraw.setPenColor(StdDraw.RED);\n        StdDraw.setPenRadius(.02);\n        p.draw();\n\n\n        // draw line segments from p to each point, one at a time, in polar order\n        StdDraw.setPenRadius();\n        StdDraw.setPenColor(StdDraw.BLUE);\n        Arrays.sort(points, p.POLAR_ORDER);\n        for (int i = 0; i < N; i++) {\n            p.drawTo(points[i]);\n            StdDraw.show(100);"],[0,"\n   "]],"start1":7087,"start2":7087,"length1":486,"length2":8}]],"length":7109,"saved":false}
{"ts":1360468575681,"patch":[[{"diffs":[[0,"raw();\n        }"],[1,"\n\n        // draw p = (x0, x1) in red\n        Point2D p = new Point2D(x0, y0);\n        StdDraw.setPenColor(StdDraw.RED);\n        StdDraw.setPenRadius(.02);\n        p.draw();\n\n\n        // draw line segments from p to each point, one at a time, in polar order\n        StdDraw.setPenRadius();\n        StdDraw.setPenColor(StdDraw.BLUE);\n        Arrays.sort(points, p.POLAR_ORDER);\n        for (int i = 0; i < N; i++) {\n            p.drawTo(points[i]);\n            StdDraw.show(100);"],[0,"\n        }\n    }"]],"start1":7075,"start2":7075,"length1":32,"length2":510}]],"length":7587,"saved":false}
{"ts":1360468582328,"patch":[[{"diffs":[[0,"  }\n"],[-1,"\n\n    public static void main(String[] args) {\n        int x0 = Integer.parseInt(args[0]);\n        int y0 = Integer.parseInt(args[1]);\n        int N = Integer.parseInt(args[2]);\n\n        StdDraw.setCanvasSize(800, 800);\n        StdDraw.setXscale(0, 100);\n        StdDraw.setYscale(0, 100);\n        StdDraw.setPenRadius(.005);\n        Point2D[] points = new Point2D[N];\n        for (int i = 0; i < N; i++) {\n            int x = StdRandom.uniform(100);\n            int y = StdRandom.uniform(100);\n            points[i] = new Point2D(x, y);\n            points[i].draw();\n        }\n\n        // draw p = (x0, x1) in red\n        Point2D p = new Point2D(x0, y0);\n        StdDraw.setPenColor(StdDraw.RED);\n        StdDraw.setPenRadius(.02);\n        p.draw();\n\n\n        // draw line segments from p to each point, one at a time, in polar order\n        StdDraw.setPenRadius();\n        StdDraw.setPenColor(StdDraw.BLUE);\n        Arrays.sort(points, p.POLAR_ORDER);\n        for (int i = 0; i < N; i++) {\n            p.drawTo(points[i]);\n            StdDraw.show(100);\n        }\n"],[0,"    "]],"start1":6510,"start2":6510,"length1":1074,"length2":8}]],"length":6521,"saved":false}
{"ts":1360468595074,"patch":[[{"diffs":[[0,"   }"],[-1,"\n\n    // convert to string\n    public String toString() {\n        return \"(\" + x + \", \" + y + \")\";\n    }\n\n    // plot using StdDraw\n    public void draw() {\n        StdDraw.point(x, y);\n    }\n\n    // draw line from this point p to q using StdDraw\n    public void drawTo(Point2D that) {\n        StdDraw.line(this.x, this.y, that.x, that.y);\n    }"],[0,"\n   "]],"start1":6164,"start2":6164,"length1":353,"length2":8}]],"length":6176,"saved":false}
{"ts":1360468628634,"patch":[[{"diffs":[[0," }\n\n"],[-1,"    // compare points according to their distance to this point\n    private class DistanceToOrder implements Comparator<Point2D> {\n        public int compare(Point2D p, Point2D q) {\n            double dist1 = distanceSquaredTo(p);\n            double dist2 = distanceSquaredTo(q);\n            if      (dist1 < dist2) return -1;\n            else if (dist1 > dist2) return +1;\n            else                    return  0;\n        }\n    }\n\n"],[0,"\n   "]],"start1":5409,"start2":5409,"length1":446,"length2":8}]],"length":5738,"saved":false}
{"ts":1360468632503,"patch":[[{"diffs":[[0," }\n\n"],[-1,"    // compare other points relative to polar angle (between 0 and 2pi) they make with this Point\n    private class PolarOrder implements Comparator<Point2D> {\n        public int compare(Point2D q1, Point2D q2) {\n            double dx1 = q1.x - x;\n            double dy1 = q1.y - y;\n            double dx2 = q2.x - x;\n            double dy2 = q2.y - y;\n\n            if      (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below\n            else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above\n            else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal\n                if      (dx1 >= 0 && dx2 < 0) return -1;\n                else if (dx2 >= 0 && dx1 < 0) return +1;\n                else                          return  0;\n            }\n            else return -ccw(Point2D.this, q1, q2);     // both above or below\n\n            // Note: ccw() recomputes dx1, dy1, dx2, and dy2\n        }\n    }\n\n"],[0,"\n   "]],"start1":4470,"start2":4470,"length1":947,"length2":8}]],"length":4799,"saved":false}
{"ts":1360468638068,"patch":[[{"diffs":[[0," }\n\n"],[-1,"    // compare points according to their polar radius\n    private static class ROrder implements Comparator<Point2D> {\n        public int compare(Point2D p, Point2D q) {\n            double delta = (p.x*p.x + p.y*p.y) - (q.x*q.x + q.y*q.y);\n            if (delta < 0) return -1;\n            if (delta > 0) return +1;\n            return 0;\n        }\n    }\n \n    // compare other points relative to atan2 angle (bewteen -pi/2 and pi/2) they make with this Point\n    private class Atan2Order implements Comparator<Point2D> {\n        public int compare(Point2D q1, Point2D q2) {\n            double angle1 = angleTo(q1);\n            double angle2 = angleTo(q2);\n            if      (angle1 < angle2) return -1;\n            else if (angle1 > angle2) return +1;\n            else                      return  0;\n        }\n    }\n"],[0,"\n\n  "]],"start1":3650,"start2":3650,"length1":827,"length2":8}]],"length":3980,"saved":false}
{"ts":1360468644700,"patch":[[{"diffs":[[0," }\n\n"],[-1,"    // compare by y-coordinate, breaking ties by x-coordinate\n    public int compareTo(Point2D that) {\n        if (this.y < that.y) return -1;\n        if (this.y > that.y) return +1;\n        if (this.x < that.x) return -1;\n        if (this.x > that.x) return +1;\n        return 0;\n    }\n\n    // compare points according to their x-coordinate\n    private static class XOrder implements Comparator<Point2D> {\n        public int compare(Point2D p, Point2D q) {\n            if (p.x < q.x) return -1;\n            if (p.x > q.x) return +1;\n            return 0;\n        }\n    }\n\n    // compare points according to their y-coordinate\n    private static class YOrder implements Comparator<Point2D> {\n        public int compare(Point2D p, Point2D q) {\n            if (p.y < q.y) return -1;\n            if (p.y > q.y) return +1;\n            return 0;\n        }\n    }\n\n"],[0,"\n\n  "]],"start1":2792,"start2":2792,"length1":866,"length2":8}]],"length":3122,"saved":false}
{"ts":1360468649617,"patch":[[{"diffs":[[0," }\n\n"],[-1,"    // twice signed area of a-b-c\n    public static double area2(Point2D a, Point2D b, Point2D c) {\n        return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);\n    }\n\n    // return Euclidean distance between this point and that point\n    public double distanceTo(Point2D that) {\n        double dx = this.x - that.x;\n        double dy = this.y - that.y;\n        return Math.sqrt(dx*dx + dy*dy);\n    }\n\n    // return square of Euclidean distance between this point and that point\n    public double distanceSquaredTo(Point2D that) {\n        double dx = this.x - that.x;\n        double dy = this.y - that.y;\n        return dx*dx + dy*dy;\n    }\n\n"],[0,"\n\n  "]],"start1":2153,"start2":2153,"length1":647,"length2":8}]],"length":2483,"saved":false}
{"ts":1360468660839,"patch":[[{"diffs":[[0," }\n\n"],[-1,"    // return the radius of this point in polar coordinates\n    public double r() { return Math.sqrt(x*x + y*y); }\n\n    // return the angle of this point in polar coordinates\n    // (between -pi/2 and pi/2)\n    public double theta() { return Math.atan2(y, x); }\n\n    // return the polar angle between this point and that point (between -pi and pi);\n    // (0 if two points are equal)\n    private double angleTo(Point2D that) {\n        double dx = that.x - this.x;\n        double dy = that.y - this.y;\n        return Math.atan2(dy, dx);\n    }\n\n    // is a->b->c a counter-clockwise turn?\n    // -1 if clockwise, +1 if counter-clockwise, 0 if collinear\n    public static int ccw(Point2D a, Point2D b, Point2D c) {\n        double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);\n        if      (area2 < 0) return -1;\n        else if (area2 > 0) return +1;\n        else                return  0;\n    }\n\n"],[0,"\n\n  "]],"start1":1251,"start2":1251,"length1":910,"length2":8}]],"length":1581,"saved":false}
{"ts":1360468682486,"patch":[[{"diffs":[[0,"nt2D"],[-1," implements Comparable<Point2D> "],[0,"{\n  "]],"start1":413,"start2":413,"length1":40,"length2":8}]],"length":1549,"saved":false}
{"ts":1360468686720,"patch":[[{"diffs":[[0,"t2D{"],[-1,"\n    public static final Comparator<Point2D> X_ORDER = new XOrder();\n    public static final Comparator<Point2D> Y_ORDER = new YOrder();\n    public static final Comparator<Point2D> R_ORDER = new ROrder();\n\n    public final Comparator<Point2D> POLAR_ORDER = new PolarOrder();\n    public final Comparator<Point2D> ATAN2_ORDER = new Atan2Order();\n    public final Comparator<Point2D> DISTANCE_TO_ORDER = new DistanceToOrder();"],[0,"\n\n  "]],"start1":414,"start2":414,"length1":431,"length2":8}]],"length":1126,"saved":false}
{"ts":1360468703328,"patch":[[{"diffs":[[0,".java\n *"],[1," http://algs4.cs.princeton.edu/12oop/Point2D.java.html *"],[0,"\n *  Imm"]],"start1":198,"start2":198,"length1":16,"length2":72}]],"length":1182,"saved":false}
{"ts":1360468707383,"patch":[[{"diffs":[[0,".java\n *"],[1," "],[0," http://"]],"start1":198,"start2":198,"length1":16,"length2":17}]],"length":1183,"saved":false}
{"ts":1360468709370,"patch":[[{"diffs":[[0,".java\n *"],[-1," "],[0," http://"]],"start1":198,"start2":198,"length1":17,"length2":16}]],"length":1182,"saved":false}
{"ts":1360468710547,"patch":[[{"diffs":[[0,".java\n *"],[1," "],[0," http://"]],"start1":198,"start2":198,"length1":16,"length2":17}]],"length":1183,"saved":false}
{"ts":1360468712982,"patch":[[{"diffs":[[0,"ava.html"],[-1," *"],[0,"\n *  Imm"]],"start1":253,"start2":253,"length1":18,"length2":16}]],"length":1181,"saved":false}
{"ts":1360470621929,"patch":[[{"diffs":[[0,";\n    }\n"],[-1,"    }\n"],[0,"}"]],"start1":1166,"start2":1166,"length1":15,"length2":9}]],"length":1175,"saved":false}
{"ts":1360470636623,"patch":[[{"diffs":[[-1,"Point2D.java\n\n\nBelow is the syntax highlighted version of Point2D.java from § Algorithms.\n\n\n"],[0,"/***"]],"start1":0,"start2":0,"length1":96,"length2":4}]],"length":1083,"saved":false}
